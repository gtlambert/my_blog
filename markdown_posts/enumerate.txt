The majority of Python coders will use the [`enumerate`](https://docs.python.org/2/library/functions.html#enumerate) keyword relatively frequently. `enumerate(iterable)` receives an `iterable` as an argument and returns an enumerate object. The basic usage is as follows:

```
>>> for idx, item in enumerate(my_list):
...     print(idx, item)
...
(0, 'apples')
(1, 'bananas')
(2, 'pears')
```

One of the most popular uses of `enumerate` is to create a `list` of tuples as follows:

```
>>> my_list = ['apples', 'bananas', 'pears']
>>> enumerate_list = list(enumerate(my_list))
>>> enumerate_list
[(0, 'apples'), (1, 'bananas'), (2, 'pears')]
```

Another popular use is the enumeration of strings:

```
>>> my_string = 'bananas'
>>> enumerated_string = list(enumerate(my_string))
>>> enumerated_string
[(0, 'b'), (1, 'a'), (2, 'n'), (3, 'a'), (4, 'n'), (5, 'a'), (6, 's')]
```

Most Pythonistas of a certain standard will be familiar with the above usage cases. What some coders will not know, however, is that `enumerate()` optionally takes a second argument. In Python version 2.6 the *start* argument was added: `enumerate(iterable, [start])`.

Before Python 2.6, people would often add or subtract from the `idx` value generated by `enumerate` to make their iteration start from the desired value. For example:

```
>>> my_list
['apples', 'bananas', 'pears']
>>> for idx, value in enumerate(my_list):
...     print(idx+1, value)
...
(1, 'apples')
(2, 'bananas')
(3, 'pears')
```

Now, instead of doing this, you can simply pass an optional `start` parameter to `enumerate`:

```
>>> for idx, value in enumerate(my_list, 1):
...         print(idx, value)
...
(1, 'apples')
(2, 'bananas')
(3, 'pears')
```

Neat!